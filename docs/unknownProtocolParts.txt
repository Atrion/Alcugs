This describes parts of the protocol which were guessed, unknown bytes which always have the same value and similar problems. I don't list all the plMessages here as the server barely cares about them - it shouldn't be its business to parse them at all, and it only does so to work around some protocol flaws and Uru bugs.

Uru network message basis:
- Some flags of the plNetMessages are unknown - even their names are guessed, sometimes supported by libPlasma: plNetSystem, plNetRelRegions (seen only on game messages), plNetNewSDL (seen only on SDL messages), plNetMsgRecvrs (seen only on game message, this flag is sometimes set even if no receivers list is attached), plNetP2P (seen on each NetMsgJoinReq). None of these flags carry any additional data.

NetMsgs which are more or less completely unknown:
- NetMsgTestAndSet: Alcugs extracts an object reference (a plUoid) out of a lot of unknown bytes, and if some byte is set to 1 (a byte which the Uru logs refer to as "lockReq"), it replies with a plServerReplyMsg contained in a NetMsgGameMessage, with some more unknown bytes and again that object reference. Almlys' old ToDo list contains an item named "Implement the storage of game objects", which I think might be related to these messages - I think the server is supposed to do more than just reply, it sounds almost as if some kind of lock has to be acquired. I can't see any issue in-game which I connect to this, except for some weird problems with footstep sounds not always working if there is a big footstep region around the link-in point, but all of this is wild guessing.
- NetMsgSetTimeout: I thought the name would make it clear, but I always and only saw it with a U32 value of "0x43340000", which, according to the logs, means 180 seconds?!?
- NetMsgPlayerPage: The format of this one is completely known, but not what it is meant to say: This message is sent once when the client starts and links to the first age, and once again when the client quits and completely leaves the game. The server currently ignores it.
- NetMsgRelevanceRegions: It seems to contain two bitfields (2 bytes each) saying what is relevant for the sender. The server currently ignores it, not knowing which events to filter according to these regions and which not (maybe all those where the plNetRelRegions flag is set?).
- NetMsgPython: The format of this message is completely unknown, but server-side Python is not supported anyway. The message is currently ignored.

NetMsgs containing unknown bytes:
- NetMsgSetMyActivePlayer: The last byte is always 0, meaning unknown.
- NetMsgFindAgeReply: The first byte of the body is always 0x1F, meaning unknown.
- NetMsgCreatePlayer: The last four bytes are always 0, meaning unknown.
- NetMsgDeletePlayer: The last two bytes are always 0, meaning unknown.
- NetMsgJoinAck: The first two bytes of the body, to which the log refers to as "joinOrder" and "ExpLevel", are always 0 and have unknown meaning.
- NetMsgGroupOwner: The byte before the last one is always 0, meaning unknown.
- NetMsgMemberUpdate, NetMsgMembersList: The structure describing a member always starts with 0x00000020, the meaning of these four bytes is unknown. In addition, the byte before the final object reference (plUoid) is always 0, again with unknown meaning (it might be the field enabled by the "reserved" flag").

Vault protocol:
- AgeLinkStruct: Between linking rule and spawn point, there are four bytes: 0x00000001. Their meaning is unknown.
- VaultNode: The meaning of 0x00000004 being set on the second 4-byte flag is unknown.

SDL protocol:
- At the beginning of what I call an "SDL State Binary" (plStateDataRecord - the binary representation of a whole SDL state), there are two bytes with unknown meaning (libPlasma calls these a flag, but doesn't explain them): either 0x0000 or 0x0001.
- At the beginning of an SDL State Variable (plStateVariable), after the first byte (indicating that there is a "notification info"), there is another one being always 0 (even libPlasma just skips it) - meaning unknown.
- Some flags of the variable in an SDL State: 0x04 (timestamp? never seen) and 0x20 (seen only for SDLs saved in the vault, but for each variable there - libPlasma calls this "want timestamp").
- I'm not sure what the correct behaviour is if I get an indexed (partial) update for an SDL containing another indexed SDL. Currently, Alcugs removes the old sub-SDL and replaces it with the new one. It might be more correct to recursively merge the sub-SDLs, but what to do if they are in a dynamically sized element, and the old and new sizes don't match - how to decide which structs to merge in this case?
